<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>검색 기반 GPT-4o mini 챗봇</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
    <style>
        body {
            transition: background-color 0.3s, color 0.3s;
        }
        .dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .chat-container {
            height: calc(100vh - 180px);
            min-height: 400px;
        }
        .user-message {
            background-color: #e3f2fd;
            border-radius: 18px 18px 2px 18px;
        }
        .bot-message {
            background-color: #f1f1f1;
            border-radius: 18px 18px 18px 2px;
        }
        .dark .user-message {
            background-color: #2d3748;
        }
        .dark .bot-message {
            background-color: #4a5568;
        }
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            margin-top: 8px;
        }
        .progress-bar {
            height: 100%;
            border-radius: 4px;
            width: 0%;
            background-color: #4299e1;
            transition: width 0.3s;
        }
        .dark .progress-container {
            background-color: #2d3748;
        }
        .source-link {
            color: #3182ce;
            text-decoration: underline;
        }
        .dark .source-link {
            color: #90cdf4;
        }
        .ellipsis {
            display: inline-block;
            width: 60px;
            text-align: left;
        }
        .typing-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: currentColor;
            margin-right: 4px;
            animation: typing 1s infinite;
        }
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes typing {
            0%, 100% { opacity: 0.3; transform: translateY(0); }
            50% { opacity: 1; transform: translateY(-2px); }
        }
        .progress-status {
            margin-top: 5px;
            font-size: 12px;
            color: #718096;
        }
        .dark .progress-status {
            color: #a0aec0;
        }
        @media print {
            .no-print {
                display: none !important;
            }
            .print-break {
                page-break-before: always;
            }
            .chat-container {
                height: auto;
                max-height: none;
                overflow: visible;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800 dark:text-white">검색 기반 GPT-4o mini 챗봇</h1>
            <div class="flex space-x-4">
                <button id="theme-toggle" class="px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition focus:outline-none focus:ring-2 focus:ring-gray-500">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </div>

        <div id="chat-box" class="bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            <div id="chat-messages" class="chat-container p-4 overflow-y-auto space-y-4">
                <div class="bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl mx-auto">
                    <p>안녕하세요! 검색 기반 GPT-4o mini 챗봇입니다. 궁금한 점이 있으시면 질문해주세요. 제가 구글 검색을 통해 정보를 찾아 답변해 드리겠습니다.</p>
                </div>
            </div>
            
            <div id="chat-form" class="p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900">
                <div class="max-w-3xl mx-auto">
                    <div id="progress-section" class="mb-3 hidden">
                        <div id="progress-status" class="progress-status"></div>
                        <div class="progress-container">
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <input type="text" id="user-input" class="flex-grow px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-l-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" placeholder="질문을 입력하세요...">
                        <button id="send-button" class="px-4 py-2 bg-blue-500 text-white rounded-r-md hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mt-6 text-sm text-gray-600 dark:text-gray-400 text-center">
            <p>© 2023 검색 기반 GPT-4o mini 챗봇</p>
        </div>
    </div>

    <script>
        // 디버깅 로그 함수
        const DEBUG = true;
        function log(...args) {
            if (DEBUG) {
                console.log('[챗봇 로그]', ...args);
            }
        }

        // 미리 설정된 API 키
        const GOOGLE_API_KEY = 'AIzaSyDndNAfYE6-_tpcQk5mRlbNGduvFN_WF2o';
        const SEARCH_ENGINE_ID = '02aca10304c1d4564';
        const OPENAI_API_KEY = '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';

        // API 키 로컬 스토리지 저장
        localStorage.setItem('google-api-key', GOOGLE_API_KEY);
        localStorage.setItem('search-engine-id', SEARCH_ENGINE_ID);
        localStorage.setItem('openai-api-key', OPENAI_API_KEY);

        // 다크 모드 토글
        const themeToggleBtn = document.getElementById('theme-toggle');
        const body = document.body;
        
        // 저장된 테마 불러오기
        if (localStorage.getItem('dark-mode') === 'true') {
            body.classList.add('dark');
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
        }
        
        themeToggleBtn.addEventListener('click', () => {
            if (body.classList.contains('dark')) {
                body.classList.remove('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
                localStorage.setItem('dark-mode', 'false');
            } else {
                body.classList.add('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
                localStorage.setItem('dark-mode', 'true');
            }
        });
        
        // 캐시 시스템 구현
        const cache = {
            search: new Map(),
            crawl: new Map(),
            
            // 캐시 유효 시간: 30분
            maxAge: 30 * 60 * 1000,
            
            getSearch(query) {
                const cacheItem = this.search.get(query);
                if (cacheItem && (Date.now() - cacheItem.timestamp < this.maxAge)) {
                    log('검색 캐시 히트:', query);
                    return cacheItem.data;
                }
                log('검색 캐시 미스:', query);
                return null;
            },
            
            setSearch(query, data) {
                this.search.set(query, {
                    data,
                    timestamp: Date.now()
                });
                log('검색 캐시 저장:', query);
            },
            
            getCrawl(url) {
                const cacheItem = this.crawl.get(url);
                if (cacheItem && (Date.now() - cacheItem.timestamp < this.maxAge)) {
                    log('크롤링 캐시 히트:', url);
                    return cacheItem.data;
                }
                log('크롤링 캐시 미스:', url);
                return null;
            },
            
            setCrawl(url, data) {
                this.crawl.set(url, {
                    data,
                    timestamp: Date.now()
                });
                log('크롤링 캐시 저장:', url);
            }
        };
        
        // 채팅 기능
        const chatMessages = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const progressSection = document.getElementById('progress-section');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        
        // 사용자 메시지 추가
        function addUserMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'user-message p-4 text-gray-800 dark:text-gray-200 ml-auto max-w-3xl';
            messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // 챗봇 메시지 추가
        function addBotMessage(message, isHTML = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl';
            
            if (isHTML) {
                messageDiv.innerHTML = message;
            } else {
                messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return messageDiv;
        }
        
        // 로딩 메시지 추가
        function addLoadingMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl';
            messageDiv.id = 'loading-message';
            
            const loadingSpan = document.createElement('span');
            loadingSpan.className = 'ellipsis';
            
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('span');
                dot.className = 'typing-dot';
                loadingSpan.appendChild(dot);
            }
            
            messageDiv.appendChild(loadingSpan);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageDiv;
        }
        
        // 로딩 메시지 업데이트
        function updateLoadingMessage(message) {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                const loadingSpan = loadingMessage.querySelector('.ellipsis');
                loadingMessage.innerHTML = `<p>${escapeHtml(message)}</p>`;
                loadingMessage.appendChild(loadingSpan);
            }
        }
        
        // 로딩 메시지 제거
        function removeLoadingMessage() {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.remove();
            }
        }
        
        // 프로그레스 상태 업데이트
        function updateProgress(percent, statusText) {
            progressBar.style.width = `${percent}%`;
            progressStatus.textContent = statusText;
            
            if (percent > 0) {
                progressSection.classList.remove('hidden');
            }
            
            if (percent >= 100) {
                setTimeout(() => {
                    progressSection.classList.add('hidden');
                    progressBar.style.width = '0%';
                }, 1000);
            }
        }
        
        // HTML 이스케이프
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // 구글 검색 함수
        async function googleSearch(query) {
            const googleApiKey = localStorage.getItem('google-api-key');
            const searchEngineId = localStorage.getItem('search-engine-id');
            
            updateProgress(10, '구글 검색 중...');
            
            // 캐시 확인
            const cachedResults = cache.getSearch(query);
            if (cachedResults) {
                updateProgress(20, '캐시된 검색 결과 사용 중...');
                return cachedResults;
            }
            
            try {
                const response = await fetch(`https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}`);
                const data = await response.json();
                
                if (data.error) {
                    log('구글 검색 API 오류:', data.error);
                    throw new Error(`구글 검색 API 오류: ${data.error.message}`);
                }
                
                updateProgress(20, '검색 결과 처리 중...');
                
                if (!data.items || data.items.length === 0) {
                    return [];
                }
                
                const results = data.items.slice(0, 8).map(item => ({
                    title: item.title,
                    link: item.link,
                    snippet: item.snippet,
                    pagemap: item.pagemap
                }));
                
                // 캐시에 저장
                cache.setSearch(query, results);
                
                return results;
            } catch (error) {
                log('구글 검색 오류:', error);
                throw error;
            }
        }
        
        // 다중 프록시 서비스
        const proxies = [
            {
                name: 'allorigins',
                url: (targetUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`,
                active: true
            },
            {
                name: 'corsproxy',
                url: (targetUrl) => `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
                active: true
            },
            {
                name: 'corsanywhere',
                url: (targetUrl) => `https://cors-anywhere.herokuapp.com/${targetUrl}`,
                active: true
            }
        ];
        
        // 웹페이지 크롤링 함수
        async function crawlWebpage(url, retryCount = 0) {
            // 캐시 확인
            const cachedContent = cache.getCrawl(url);
            if (cachedContent) {
                return cachedContent;
            }
            
            // 최대 재시도 횟수
            const maxRetries = 3;
            
            // 활성화된 프록시 찾기
            const activeProxies = proxies.filter(p => p.active);
            
            // 모든 프록시가 비활성화되었는지 확인
            if (activeProxies.length === 0) {
                return `모든 프록시 서비스가 실패했습니다. URL: ${url}`;
            }
            
            // 사용할 프록시 선택
            const proxyIndex = retryCount % activeProxies.length;
            const proxy = activeProxies[proxyIndex];
            
            try {
                // URL 유효성 확인
                if (!url.startsWith('http')) {
                    throw new Error('유효하지 않은 URL입니다.');
                }
                
                // 특정 파일 형식 처리
                const fileExtension = url.split('.').pop().toLowerCase();
                const nonHtmlExtensions = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'zip', 'rar', 'jpg', 'jpeg', 'png', 'gif'];
                
                if (nonHtmlExtensions.includes(fileExtension)) {
                    return `${fileExtension.toUpperCase()} 파일은 내용을 추출할 수 없습니다. URL: ${url}`;
                }
                
                // 타임아웃 설정 (15초)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);
                
                // 프록시 URL 생성
                const proxyUrl = proxy.url(url);
                
                // 요청 헤더
                const headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7'
                };
                
                log(`[${proxy.name}] 크롤링 중:`, url);
                
                const response = await fetch(proxyUrl, { 
                    signal: controller.signal,
                    headers: headers
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP 오류: ${response.status}`);
                }
                
                // 콘텐츠 타입 확인
                const contentType = response.headers.get('content-type') || '';
                
                // HTML이 아닌 경우 처리
                if (!contentType.includes('text/html') && !contentType.includes('application/xhtml+xml')) {
                    if (contentType.includes('application/json')) {
                        const json = await response.json();
                        return JSON.stringify(json, null, 2);
                    } else if (contentType.includes('text/plain')) {
                        const text = await response.text();
                        return text.substring(0, 5000);
                    } else {
                        return `지원되지 않는 콘텐츠 타입: ${contentType}, URL: ${url}`;
                    }
                }
                
                const html = await response.text();
                
                // 내용이 없는 경우
                if (!html || html.trim().length === 0) {
                    throw new Error('빈 응답 받음');
                }
                
                // DOM 파서 생성
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // 메타데이터 추출
                const title = doc.querySelector('title')?.textContent || url;
                const metaDescription = doc.querySelector('meta[name="description"]')?.getAttribute('content') || '';
                
                // 불필요한 요소 제거
                const elementsToRemove = ['script', 'style', 'svg', 'img', 'iframe', 'nav', 'header', 'footer', 'aside', 'form', 'noscript'];
                elementsToRemove.forEach(tag => {
                    doc.querySelectorAll(tag).forEach(el => el.remove());
                });
                
                // 주요 콘텐츠 영역 찾기
                let mainContent = doc.querySelector('main') || 
                                doc.querySelector('article') || 
                                doc.querySelector('.content, .main-content, .post-content, .entry-content, #content, #main') || 
                                doc.body;
                
                // 본문 텍스트 추출
                let text = '';
                
                // 주요 콘텐츠에서 텍스트 노드만 추출
                function extractText(node) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        return node.textContent.trim();
                    }
                    
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // 무시할 요소인지 확인
                        if (elementsToRemove.includes(node.nodeName.toLowerCase())) {
                            return '';
                        }
                        
                        let result = '';
                        
                        // 제목 요소인 경우 줄바꿈 추가
                        const isHeading = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(node.nodeName);
                        const isParagraph = node.nodeName === 'P';
                        
                        // 자식 노드 처리
                        for (const child of node.childNodes) {
                            result += extractText(child) + ' ';
                        }
                        
                        result = result.trim();
                        
                        // 제목과 단락에 줄바꿈 추가
                        if (isHeading) {
                            result = '\n## ' + result + '\n';
                        } else if (isParagraph) {
                            result = '\n' + result + '\n';
                        }
                        
                        return result;
                    }
                    
                    return '';
                }
                
                text = extractText(mainContent);
                
                // 메타데이터 추가
                text = `제목: ${title}\n설명: ${metaDescription}\n\n${text}`;
                
                // 텍스트 정리
                text = text
                    .replace(/\s+/g, ' ')
                    .replace(/\n+/g, '\n')
                    .trim();
                
                // 텍스트가 너무 길면 앞부분만 사용
                if (text.length > 8000) {
                    text = text.substring(0, 8000) + '...';
                }
                
                // 캐시에 저장
                cache.setCrawl(url, text);
                
                log('크롤링 완료:', url, '길이:', text.length);
                return text;
            } catch (error) {
                log(`[${proxy.name}] '${url}' 크롤링 오류:`, error);
                
                // 현재 프록시를 비활성화
                proxy.active = false;
                log(`${proxy.name} 프록시 비활성화됨`);
                
                // 재시도 횟수가 최대치에 도달했는지 확인
                if (retryCount >= maxRetries) {
                    // 모든 프록시 다시 활성화
                    proxies.forEach(p => p.active = true);
                    return `크롤링 최대 재시도 횟수 초과. URL: ${url}, 오류: ${error.message}`;
                }
                
                // 다른 프록시로 재시도
                log(`다른 프록시로 재시도 (${retryCount + 1}/${maxRetries})`);
                return crawlWebpage(url, retryCount + 1);
            }
        }
        
        // 병렬 크롤링 함수
        async function crawlWebpages(searchResults) {
            updateProgress(30, '웹페이지 크롤링 중...');
            
            try {
                const totalSites = searchResults.length;
                log(`${totalSites}개 사이트 크롤링 시작`);
                
                const crawlPromises = searchResults.map((result, index) => {
                    return crawlWebpage(result.link).then(content => {
                        updateProgress(30 + Math.floor((index + 1) * 40 / totalSites), `${totalSites}개 중 ${index + 1}개 사이트 크롤링 완료`);
                        return {
                            ...result,
                            content
                        };
                    });
                });
                
                // Promise.all을 사용한 병렬 처리
                const results = await Promise.all(crawlPromises);
                log('모든 사이트 크롤링 완료');
                return results;
            } catch (error) {
                log('크롤링 오류:', error);
                throw error;
            }
        }
        
        // GPT 응답 함수
        async function getGptResponse(question, crawledResults) {
            const openaiApiKey = localStorage.getItem('openai-api-key');
            
            updateProgress(80, 'GPT-4o mini 응답 생성 중...');
            
            try {
                // 크롤링 결과에서 컨텍스트 구성
                let context = '';
                crawledResults.forEach((result, index) => {
                    context += `[출처 ${index + 1}: ${result.title}]\n${result.content}\n\n`;
                });
                
                const messages = [
                    {
                        role: 'system',
                        content: `당신은 웹 검색을 활용하는 지식 챗봇입니다. 다음 정보를 바탕으로 정확하고 상세한 답변을 한국어로 제공하세요. 
                        정보가 충분하지 않은 경우 솔직하게 부족한 정보라고 설명하세요. 
                        답변에 사용한 출처를 [출처 번호]와 같은 형식으로 인용하고, 마지막에 참고한 모든 출처 목록을 이름과 링크와 함께 제공하세요.`
                    },
                    {
                        role: 'user',
                        content: `질문: ${question}\n\n검색 결과:\n${context}`
                    }
                ];
                
                log('GPT 요청 전송 중');
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openaiApiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: messages,
                        temperature: 0.7
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    log('OpenAI API 오류:', data.error);
                    throw new Error(`OpenAI API 오류: ${data.error.message}`);
                }
                
                updateProgress(100, '응답 생성 완료');
                log('GPT 응답 받음');
                
                let answer = data.choices[0].message.content;
                
                // 출처 링크 추가
                crawledResults.forEach((result, index) => {
                    const sourceNumber = index + 1;
                    const sourceRegex = new RegExp(`\\[출처 ${sourceNumber}\\]`, 'g');
                    answer = answer.replace(sourceRegex, `<a href="${result.link}" target="_blank" class="source-link">[출처 ${sourceNumber}]</a>`);
                    
                    // 출처 목록에도 링크 추가
                    const sourceListRegex = new RegExp(`출처 ${sourceNumber}: ([^\\n]+)`, 'g');
                    answer = answer.replace(sourceListRegex, `출처 ${sourceNumber}: <a href="${result.link}" target="_blank" class="source-link">$1</a>`);
                });
                
                return answer;
            } catch (error) {
                log('GPT 응답 오류:', error);
                throw error;
            }
        }
        
        // 메시지 처리 함수
        async function processMessage(message) {
            // 사용자 메시지 표시
            addUserMessage(message);
            
            // 로딩 메시지 표시
            const loadingMessage = addLoadingMessage();
            
            try {
                // 구글 검색
                updateLoadingMessage('구글 검색 중...');
                const searchResults = await googleSearch(message);
                
                if (searchResults.length === 0) {
                    removeLoadingMessage();
                    addBotMessage('검색 결과가 없습니다. 다른 질문을 해보세요.');
                    return;
                }
                
                // 검색 결과 크롤링
                updateLoadingMessage('웹페이지에서 정보 추출 중...');
                const crawledResults = await crawlWebpages(searchResults);
                
                // GPT 응답 요청
                updateLoadingMessage('GPT-4o mini가 응답 생성 중...');
                const gptResponse = await getGptResponse(message, crawledResults);
                
                // 로딩 메시지 제거 및 응답 표시
                removeLoadingMessage();
                addBotMessage(gptResponse, true);
                
                // 검색 결과 표시
                const sourcesDiv = document.createElement('div');
                sourcesDiv.className = 'mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400';
                
                let sourcesHtml = '<p class="font-medium mb-2">검색 결과 사이트:</p><ul class="list-disc list-inside">';
                
                searchResults.forEach((result, index) => {
                    sourcesHtml += `<li><a href="${result.link}" target="_blank" class="source-link">${result.title}</a></li>`;
                });
                
                sourcesHtml += '</ul>';
                sourcesDiv.innerHTML = sourcesHtml;
                
                const lastMessage = chatMessages.lastElementChild;
                lastMessage.appendChild(sourcesDiv);
                
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } catch (error) {
                log('오류:', error);
                removeLoadingMessage();
                addBotMessage(`오류가 발생했습니다: ${error.message}`);
            }
        }
        
        // 메시지 전송 이벤트
        sendButton.addEventListener('click', () => {
            const message = userInput.value.trim();
            
            if (message) {
                userInput.value = '';
                userInput.focus();
                
                processMessage(message);
            }
        });
        
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendButton.click();
            }
        });
        
        // 초기화
        userInput.focus();
    </script>
</body>
</html>
